<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <style>*{box-sizing:border-box;margin:0;padding:0}body{font-family:system-ui,-apple-system,sans-serif;color:#333;line-height:1.6}a{color:inherit;text-decoration:none}code{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}.container{max-width:960px;margin:0 auto;padding:0 20px}.header{background:#1a1a2e;color:#fff;padding:16px 0;position:sticky;top:0;z-index:10}.header-inner{max-width:960px;margin:0 auto;padding:0 20px;display:flex;align-items:center;justify-content:space-between}.brand{font-size:1.3em;font-weight:700;color:#fff}.nav{display:flex;gap:24px}.nav a{color:#ccc;font-size:14px;transition:color .2s}.nav a:hover{color:#fff}.footer{padding:32px 0;background:#1a1a2e;color:#999;text-align:center;font-size:.9em}@media(max-width:768px){.nav{gap:12px}.nav a{font-size:13px}}.btc-page.v2{padding:40px 0}.btc-page.v2 h1.v2{font-size:2.2em;color:#1a1a2e;margin-bottom:8px}.subtitle.v2{color:#666;margin-bottom:32px;font-size:1.05em}.btc-card.v2{background:#fff;padding:2rem;border-radius:8px;border:1px solid #e5e7eb;text-align:center;max-width:500px;margin-bottom:32px}.price-header.v2{display:flex;justify-content:space-between;margin-bottom:1rem;color:#666}.symbol.v2{font-weight:600;color:#f7931a;font-size:1.1em}.update-time.v2{font-size:.875rem}.price.v2{font-size:2.5rem;font-weight:700;margin:1rem 0;color:#1a1a2e}.disclaimer.v2{display:block;color:#888;margin-top:1rem;padding-top:1rem;border-top:1px solid #e9ecef;font-size:.8rem}.loading.v2{color:#666;font-size:1.1rem;padding:2rem 0}.error.v2{color:#e53e3e;margin-bottom:1rem}.retry-btn.v2{padding:8px 16px;background:#1a1a2e;color:#fff;border:none;border-radius:4px;cursor:pointer}.retry-btn.v2:hover{background:#0f3460}.btc-code.v2{max-width:700px}.btc-code.v2 h2.v2{font-size:1.3em;color:#1a1a2e;margin-bottom:8px}.btc-code.v2>p.v2{color:#555;margin-bottom:16px;font-size:.95em}.btc-code.v2 code.v2{background:#f1f5f9;padding:2px 6px;border-radius:3px;font-size:.85em}.btc-code.v2 pre.v2{background:#1a1a2e;color:#e0e0e0;padding:16px;border-radius:6px;overflow-x:auto;font-size:13px;line-height:1.6}.btc-code.v2 pre.v2 code.v2{background:transparent;padding:0;font-size:inherit}.hero.v0{background:linear-gradient(135deg,#1a1a2e 0%,#16213e 50%,#0f3460 100%);color:#fff;padding:80px 0;text-align:center}.hero.v0 h1.v0{font-size:3em;margin-bottom:16px;font-weight:800}.tagline.v0{font-size:1.2em;color:#b8c5d6;max-width:600px;margin:0 auto 24px}.hero-badges.v0{display:flex;gap:12px;justify-content:center}.badge.v0{background:rgba(255,255,255,.12);padding:6px 16px;border-radius:20px;font-size:13px;font-weight:500;border:1px solid rgba(255,255,255,.2)}.hero-size.v0{margin-top:20px;font-size:.95em;color:#8899b0}.highlights.v0{padding:60px 0;background:#f8f9fa}.highlight-grid.v0{display:grid;grid-template-columns:repeat(3,1fr);gap:24px}.highlight-card.v0{padding:24px;background:#fff;border-radius:8px;box-shadow:0 1px 3px rgba(0,0,0,.08)}.highlight-card.v0 h3.v0{font-size:1.1em;margin-bottom:8px;color:#1a1a2e}.highlight-card.v0 p.v0{font-size:.95em;color:#555}.explore.v0{padding:60px 0}.explore.v0 h2.v0{text-align:center;font-size:2em;margin-bottom:40px;color:#1a1a2e}.explore-grid.v0{display:grid;grid-template-columns:repeat(3,1fr);gap:24px}.explore-card.v0{padding:24px;border:1px solid #e5e7eb;border-radius:8px}.explore-card.v0 h3.v0{font-size:1.1em;margin-bottom:8px;color:#1a1a2e}.explore-card.v0 p.v0{font-size:.9em;color:#666;margin-bottom:16px}.explore-links.v0{display:flex;gap:12px}.explore-links.v0 a.v0{display:inline-block;padding:8px 16px;border-radius:4px;font-size:13px;font-weight:500;background:#1a1a2e;color:#fff;transition:background .2s}.explore-links.v0 a.v0:hover{background:#0f3460}.explore-links.v0 a[external].v0{background:#f8f9fa;color:#1a1a2e;border:1px solid #ddd}.explore-links.v0 a[external].v0:hover{background:#e5e7eb}.features.v0{padding:60px 0;background:#f8f9fa}.features.v0 h2.v0{text-align:center;font-size:2em;margin-bottom:40px;color:#1a1a2e}.feature-grid.v0{display:grid;grid-template-columns:repeat(3,1fr);gap:24px}.feature-card.v0{padding:24px;border:1px solid #e5e7eb;border-radius:8px;text-align:center;background:#fff}.feature-icon.v0{font-size:2em;margin-bottom:12px}.feature-card.v0 h3.v0{font-size:1em;margin-bottom:8px;color:#1a1a2e}.feature-card.v0 p.v0{font-size:.9em;color:#666}.feature-card.v0 code.v0{background:#f1f5f9;padding:2px 6px;border-radius:3px;font-size:.85em}.quickstart.v0{padding:60px 0}.quickstart.v0 h2.v0{text-align:center;font-size:2em;margin-bottom:12px;color:#1a1a2e}.prereq.v0{text-align:center;color:#666;margin-bottom:32px;font-size:.95em}.prereq.v0 a.v0{color:#4a7fff;text-decoration:underline}.steps.v0{max-width:700px;margin:0 auto}.step.v0{display:flex;gap:20px;margin-bottom:32px}.step-num.v0{width:36px;height:36px;background:#1a1a2e;color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;flex-shrink:0}.step-content.v0{flex:1}.step-content.v0 h3.v0{font-size:1.1em;margin-bottom:12px;color:#1a1a2e}.step-content.v0 pre.v0{background:#1a1a2e;color:#e0e0e0;padding:16px;border-radius:6px;overflow-x:auto;font-size:13px;line-height:1.5}.step-hint.v0{font-size:.9em;color:#666;margin-top:8px}.step-hint.v0 a.v0{color:#4a7fff;text-decoration:underline}.step-hint.v0 code.v0{background:#e5e7eb;padding:2px 6px;border-radius:3px;font-size:.85em}@media(max-width:768px){.highlight-grid.v0,.feature-grid.v0,.explore-grid.v0{grid-template-columns:1fr}.hero.v0 h1.v0{font-size:2em}.tagline.v0{font-size:1em}}.manual.v1{padding:40px 0}.manual.v1 h1.v1{font-size:2.2em;color:#1a1a2e;margin-bottom:8px}.intro.v1{color:#666;margin-bottom:32px;font-size:1.05em}.toc.v1{margin-bottom:40px;padding:20px;background:#f8f9fa;border-radius:8px}.toc.v1 h2.v1{font-size:1em;margin-bottom:12px;color:#1a1a2e}.toc.v1 ul.v1{list-style:none;padding:0;margin:0;display:flex;flex-wrap:wrap;gap:8px}.toc.v1 li.v1 a.v1{display:inline-block;padding:6px 14px;background:#1a1a2e;color:#fff;border-radius:4px;font-size:13px;transition:background .2s}.toc.v1 li.v1 a.v1:hover{background:#0f3460}.manual.v1 section.v1{margin-bottom:32px;padding:24px;border:1px solid #e5e7eb;border-radius:8px;background:#fff}.manual.v1 section.v1 h2.v1{font-size:1.3em;color:#1a1a2e;margin-bottom:8px}.manual.v1 section.v1>p.v1{color:#555;margin-bottom:16px;font-size:.95em}.manual.v1 section.v1 code.v1{background:#f1f5f9;padding:2px 6px;border-radius:3px;font-size:.85em}.manual.v1 section.v1 pre.v1{background:#1a1a2e;color:#e0e0e0;padding:16px;border-radius:6px;overflow-x:auto;font-size:13px;line-height:1.6}.manual.v1 section.v1 pre.v1 code.v1{background:transparent;padding:0;font-size:inherit}@media(max-width:768px){.toc.v1 ul.v1{flex-direction:column}}</style>
    </head>
    <body>
        <header class="header"><div class="header-inner"><a href="./" class="brand">PrevelteKit</a><nav class="nav"><a href="manual">Manual</a><a href="bitcoin">Bitcoin Demo</a><a href="https://github.com/tbocek/preveltekit" external>GitHub</a></nav></div></header><div id="content"><!--r0s--><div class="manual v1"><div class="container v1"><h1 class="v1">Manual</h1><p class="intro v1">API reference for PrevelteKit. Each section shows the API and a code example.</p><nav class="toc v1"><h2 class="v1">Contents</h2><ul class="v1"><li class="v1"><a href="#stores" external class="v1">Stores</a></li><li class="v1"><a href="#html-and-binding" external class="v1">HTML &amp; Binding</a></li><li class="v1"><a href="#events" external class="v1">Events</a></li><li class="v1"><a href="#conditionals" external class="v1">Conditionals</a></li><li class="v1"><a href="#lists" external class="v1">Lists</a></li><li class="v1"><a href="#components" external class="v1">Components</a></li><li class="v1"><a href="#routing" external class="v1">Routing</a></li><li class="v1"><a href="#fetch" external class="v1">Fetch</a></li><li class="v1"><a href="#storage" external class="v1">Storage</a></li><li class="v1"><a href="#timers" external class="v1">Timers</a></li><li class="v1"><a href="#lifecycle" external class="v1">Lifecycle</a></li></ul></nav><section id="stores" class="v1"><h2 class="v1">Stores</h2><p class="v1">Reactive state containers. When a store value changes, all bound DOM elements update automatically.</p><pre class="v1"><code class="v1">// Create a store with an initial value
count := p.New(0)              // *Store[int]
name := p.New("hello")         // *Store[string]
dark := p.New(false)           // *Store[bool]

// Read and write
count.Get()                    // returns current value
count.Set(5)                   // set new value
count.Update(func(v int) int { // transform current value
    return v + 1
})

// Subscribe to changes
count.OnChange(func(v int) {
    // called whenever count changes
})</code></pre></section><section id="html-and-binding" class="v1"><h2 class="v1">HTML &amp; Binding</h2><p class="v1">Build DOM trees with <code class="v1">p.Html()</code>. Embed stores directly — they become live text nodes.</p><pre class="v1"><code class="v1">// Static HTML with reactive store interpolation
p.Html(`&lt;p>Count: &lt;strong>`, count, `&lt;/strong>&lt;/p>`)

// Two-way binding for inputs
p.Html(`&lt;input type="text">`).Bind(name)     // *Store[string]
p.Html(`&lt;input type="text">`).Bind(age)      // *Store[int]
p.Html(`&lt;input type="checkbox">`).Bind(dark)  // *Store[bool]
p.Html(`&lt;textarea>`).Bind(notes)              // *Store[string]

// Dynamic attributes
p.Html(`&lt;div>`).Attr("data-theme", theme)

// Conditional attributes (additive for same attribute name)
p.Html(`&lt;div>`).AttrIf("class",
    p.Cond(func() bool { return dark.Get() }, dark), "active")

// Raw HTML rendering (not escaped)
p.BindAsHTML(rawHTML)</code></pre></section><section id="events" class="v1"><h2 class="v1">Events</h2><p class="v1">Attach event handlers with <code class="v1">.On()</code>. Chain modifiers for common patterns.</p><pre class="v1"><code class="v1">// Click handler
p.Html(`&lt;button>Click&lt;/button>`).On("click", handler)

// Form submit with preventDefault
p.Html(`&lt;form>...&lt;/form>`).On("submit", handler).PreventDefault()

// Stop event bubbling
p.Html(`&lt;button>Inner&lt;/button>`).On("click", handler).StopPropagation()

// Inline handler
p.Html(`&lt;button>+5&lt;/button>`).On("click", func() {
    count.Update(func(v int) int { return v + 5 })
})</code></pre></section><section id="conditionals" class="v1"><h2 class="v1">Conditionals</h2><p class="v1">Show or hide content reactively with <code class="v1">p.If()</code>. Supports <code class="v1">ElseIf</code> and <code class="v1">Else</code> chains.</p><pre class="v1"><code class="v1">// Simple if
p.If(p.Cond(func() bool { return count.Get() > 0 }, count),
    p.Html(`&lt;p>Positive&lt;/p>`),
)

// If / ElseIf / Else
p.If(p.Cond(func() bool { return score.Get() >= 90 }, score),
    p.Html(`&lt;p>Grade: A&lt;/p>`),
).ElseIf(p.Cond(func() bool { return score.Get() >= 80 }, score),
    p.Html(`&lt;p>Grade: B&lt;/p>`),
).Else(
    p.Html(`&lt;p>Grade: F&lt;/p>`),
)

// p.Cond(predicateFn, ...dependencyStores)</code></pre></section><section id="lists" class="v1"><h2 class="v1">Lists</h2><p class="v1">Reactive lists with <code class="v1">p.NewList()</code>. Render with <code class="v1">p.Each()</code>.</p><pre class="v1"><code class="v1">// Create a reactive list
items := p.NewList[string]("Apple", "Banana", "Cherry")

// Mutate — triggers re-render
items.Append("Date")
items.RemoveAt(0)
items.Set([]string{"Mango", "Papaya"})
items.Clear()

// Reactive length
items.Len()  // *Store[int] — updates automatically

// Render each item
p.Each(items, func(item string, i int) p.Node {
    return p.Html(`&lt;li>`, p.Itoa(i), `: `, item, `&lt;/li>`)
}).Else(
    p.Html(`&lt;p>No items&lt;/p>`),
)</code></pre></section><section id="components" class="v1"><h2 class="v1">Components</h2><p class="v1">Components are Go structs implementing <code class="v1">Render() p.Node</code>. Use <code class="v1">p.Comp()</code> to embed them.</p><pre class="v1"><code class="v1">// Define a component
type Badge struct {
    Label *p.Store[string]
}

func (b *Badge) Render() p.Node {
    return p.Html(`&lt;span class="badge">`, b.Label, `&lt;/span>`)
}

// Scoped CSS
func (b *Badge) Style() string {
    return `.badge{background:#007bff;color:#fff}`
}

// Use a component (props are struct fields)
p.Comp(&amp;Badge{Label: p.New("New")})

// Component with slot (child content)
p.Comp(&amp;Card{Title: p.New("Hello")},
    p.Html(`&lt;p>Slot content here&lt;/p>`),
)

// Inside the component, render slot content:
p.Slot()

// Callback props for component events
type Button struct {
    Label   *p.Store[string]
    OnClick func()
}

// Shared stores: pass the same *Store to multiple components
theme := p.New("light")
p.Comp(&amp;Header{Theme: theme})
p.Comp(&amp;Sidebar{Theme: theme})
// both components read/write the same store</code></pre></section><section id="routing" class="v1"><h2 class="v1">Routing</h2><p class="v1">Client-side routing with <code class="v1">p.NewRouter()</code>. Each route maps to a component and an SSR HTML file.</p><pre class="v1"><code class="v1">// Define routes
routes := []p.Route{
    {Path: "/", HTMLFile: "index.html", SSRPath: "/", Component: home},
    {Path: "/about", HTMLFile: "about.html", SSRPath: "/about", Component: about},
}

// Start the router (in OnMount)
router := p.NewRouter(currentComponent, routes, "unique-id")
router.NotFound(func() { currentComponent.Set(nil) })
router.Start()

// Store[Component] holds the active route component
currentComponent *p.Store[p.Component]

// Links: client-side (default) vs server-side
// &lt;a href="/about">About&lt;/a>           (SPA navigation)
// &lt;a href="/about" external>About&lt;/a>  (full page reload)

// Store[Component] for local tabs (non-router):
activeTab := p.New[p.Component](tab1)
activeTab.WithOptions(tab1, tab2, tab3)
activeTab.Set(tab2)  // switches displayed component</code></pre></section><section id="fetch" class="v1"><h2 class="v1">Fetch</h2><p class="v1">Type-safe HTTP requests with automatic JSON encoding/decoding via <code class="v1">js</code> struct tags.</p><pre class="v1"><code class="v1">// Define response type with js tags
type User struct {
    ID   int    `js:"id"`
    Name string `js:"name"`
}

// GET
go func() {
    user, err := p.Get[User]("https://api.example.com/user/1")
}()

// POST (send body, decode response)
go func() {
    created, err := p.Post[User](url, newUser)
}()

// PUT, PATCH, DELETE
result, err := p.Put[T](url, body)
result, err := p.Patch[T](url, body)
result, err := p.Delete[T](url)

// Advanced: custom headers and abort
signal, abort := p.NewAbortController()
go func() {
    result, err := p.Fetch[T](url, &amp;p.FetchOptions{
        Method:  "GET",
        Headers: map[string]string{"Authorization": "Bearer token"},
        Signal:  signal,
    })
}()
abort()  // cancel the request</code></pre></section><section id="storage" class="v1"><h2 class="v1">Storage</h2><p class="v1">Persist state to localStorage. <code class="v1">LocalStore</code> auto-syncs on every <code class="v1">Set()</code>.</p><pre class="v1"><code class="v1">// Auto-persisted store (syncs on every Set)
theme := p.NewLocalStore("theme", "light")
theme.Set("dark")  // automatically saved to localStorage
theme.Store        // *Store[string] — use in Html() like any store

// Manual localStorage API
p.SetStorage("notes", "hello")
saved := p.GetStorage("notes")
p.RemoveStorage("notes")
p.ClearStorage()</code></pre></section><section id="timers" class="v1"><h2 class="v1">Timers</h2><p class="v1">Debounce, throttle, setTimeout, and setInterval — all return cleanup functions.</p><pre class="v1"><code class="v1">// Debounce: fires after idle period
doSearch, cleanup := p.Debounce(300, func() {
    // fires 300ms after last call
})
doSearch()   // call repeatedly — only last one fires
cleanup()    // cancel pending

// Throttle: max once per interval
onClick := p.Throttle(500, func() {
    // max once per 500ms
})

// SetTimeout: fires once after delay
cancel := p.SetTimeout(2000, func() {
    // fires after 2 seconds
})
cancel()  // cancel before it fires

// SetInterval: fires repeatedly
stop := p.SetInterval(60000, func() {
    // fires every 60 seconds
})
stop()  // stop the interval</code></pre></section><section id="lifecycle" class="v1"><h2 class="v1">Lifecycle</h2><p class="v1">Components can implement lifecycle hooks for setup and teardown.</p><pre class="v1"><code class="v1">// OnMount: called when component becomes active
func (c *MyComp) OnMount() {
    if p.IsBuildTime {
        return  // skip side effects during SSR
    }
    // fetch data, start timers, etc.
}

// OnDestroy: called when component is removed (e.g. route change)
func (c *MyComp) OnDestroy() {
    if c.stopTimer != nil {
        c.stopTimer()
    }
}

// New: constructor — create stores, initialize state
func (c *MyComp) New() p.Component {
    return &amp;MyComp{
        Count: p.New(0),
        Name:  p.New(""),
    }
}

// GlobalStyle: CSS applied to entire page (on App component)
func (a *App) GlobalStyle() string { return `body{margin:0}` }

// Style: scoped CSS (auto-prefixed to this component)
func (c *MyComp) Style() string { return `.btn{color:red}` }

// p.IsBuildTime: true during SSR, false in WASM
// Use to guard browser-only code (fetch, timers, DOM access)</code></pre></section></div></div><!--r0--></div><footer class="footer"><div class="container"><p>SSR + WASM hydration &bull; Pure Go &bull; Static deployment &bull; No JavaScript required</p></div></footer>
        <script src="wasm_exec.js"></script>
        <script>
            const go = new Go();
            WebAssembly.instantiateStreaming(
                fetch("main.wasm"),
                go.importObject,
            ).then((result) => go.run(result.instance));
        </script>
        <script>
            new EventSource("/livereload").onmessage = () => location.reload();
        </script>
    </body>
</html>
