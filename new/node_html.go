//go:build !wasm

package preveltekit

import (
	"fmt"
	"strings"
)

// BuildContext holds state during HTML generation.
type BuildContext struct {
	// Embed shared ID counter logic (used by both SSR and WASM)
	IDCounter

	// SlotContent holds HTML to be rendered in place of <slot/> elements
	SlotContent string

	// CollectedStyles holds scoped CSS from nested components (deduplicated by component name)
	CollectedStyles map[string]string

	// CollectedGlobalStyles holds unscoped CSS from GlobalStyle() (deduplicated by component name)
	CollectedGlobalStyles map[string]string

	// ScopeAttr is the CSS scoping class for the current component (e.g., "v0").
	// When set, all HTML tags rendered in this context get this class injected.
	ScopeAttr string
}

// =============================================================================
// ID Generation
// =============================================================================
//
// There are two types of IDs used in the generated HTML:
//
// 1. ELEMENT IDs - Used in HTML id="..." attributes for DOM element lookup
//    - Generated by: NextBindID, NextClassID, NextAttrID
//    - Format: Full prefix + local ID (e.g., "components_ev0", "basics_b0")
//    - Used by: Events, InputBindings, AttrBindings, AttrCondBindings
//    - These IDs appear in the actual HTML element's id attribute
//
// 2. MARKER IDs - Used in HTML comments <!--marker--> for text/block insertion points
//    - Generated by: NextTextMarker, NextIfMarker, NextEachMarker, NextCompMarker
//    - Format: Shortened prefix + local ID (e.g., "components_c3_t0", "basics_i0")
//    - Used by: TextBindings, IfBlocks, EachBlocks
//    - These IDs appear in HTML comments
// =============================================================================

// NewBuildContext creates a new build context for HTML generation.
func NewBuildContext() *BuildContext {
	return &BuildContext{
		CollectedStyles:       make(map[string]string),
		CollectedGlobalStyles: make(map[string]string),
	}
}

// Child creates a child context for a nested component.
func (ctx *BuildContext) Child(compID string) *BuildContext {
	prefix := compID
	if ctx.Prefix != "" {
		prefix = ctx.Prefix + "_" + compID
	}
	return &BuildContext{
		IDCounter: IDCounter{Prefix: prefix},
	}
}

// =============================================================================
// ToHTML implementations
// =============================================================================

// ToHTML generates HTML for a raw HTML node with embedded nodes.
func (h *HtmlNode) ToHTML(ctx *BuildContext) string {
	html := h.renderParts(ctx)

	if len(h.AttrConds) > 0 || len(h.Events) > 0 {
		html = h.injectChainedAttrs(html, ctx)
	}

	if h.BoundStore != nil {
		html = h.injectBind(html, ctx)
	}

	return html
}

// injectBind handles two-way input binding by injecting id/value/checked attributes.
// Uses a unique bind ID (not the store ID) so multiple inputs can bind the same store.
func (h *HtmlNode) injectBind(html string, ctx *BuildContext) string {
	localID := ctx.NextBindID()
	bindID := ctx.FullID(localID)

	switch s := h.BoundStore.(type) {
	case *Store[string]:
		if strings.HasPrefix(strings.TrimSpace(strings.ToLower(html)), "<textarea") {
			return injectTextareaContent(html, bindID, s.Get())
		}
		return injectAttrs(html, fmt.Sprintf(`id="%s" value="%s"`, bindID, escapeAttr(s.Get())))

	case *Store[int]:
		return injectAttrs(html, fmt.Sprintf(`id="%s" value="%d"`, bindID, s.Get()))

	case *Store[bool]:
		checked := ""
		if s.Get() {
			checked = " checked"
		}
		return injectAttrs(html, fmt.Sprintf(`id="%s"%s`, bindID, checked))
	}

	return html
}

// renderParts renders the Parts slice to HTML string.
func (h *HtmlNode) renderParts(ctx *BuildContext) string {
	var sb strings.Builder

	for i := 0; i < len(h.Parts); i++ {
		part := h.Parts[i]
		switch v := part.(type) {
		case string:
			if ctx.ScopeAttr != "" {
				sb.WriteString(injectScopeClass(v, ctx.ScopeAttr))
			} else {
				sb.WriteString(v)
			}
		case Node:
			sb.WriteString(nodeToHTML(v, ctx))
		case NodeAttr:
			sb.WriteString(attrToHTMLString(v, ctx))
		case *Store[string]:
			bindNode := &BindNode{StoreRef: v, IsHTML: false}
			sb.WriteString(bindNode.ToHTML(ctx))
		case *Store[int]:
			bindNode := &BindNode{StoreRef: v, IsHTML: false}
			sb.WriteString(bindNode.ToHTML(ctx))
		case *Store[bool]:
			bindNode := &BindNode{StoreRef: v, IsHTML: false}
			sb.WriteString(bindNode.ToHTML(ctx))
		case *Store[float64]:
			bindNode := &BindNode{StoreRef: v, IsHTML: false}
			sb.WriteString(bindNode.ToHTML(ctx))
		case *Store[Component]:
			comp := v.Get()
			if comp != nil && len(v.Options()) > 0 {
				localMarker := ctx.NextRouteMarker()
				markerID := ctx.FullID(localMarker)

				// Render ALL option components to advance counters in sync with WASM
				var activeHTML string
				seen := make(map[string]bool)
				for _, opt := range v.Options() {
					optComp, ok := opt.(Component)
					if !ok || optComp == nil {
						continue
					}
					name := componentName(optComp)
					if seen[name] {
						continue
					}
					seen[name] = true

					branchCtx := ctx.Child(name)
					branchCtx.CollectedStyles = ctx.CollectedStyles
					branchCtx.CollectedGlobalStyles = ctx.CollectedGlobalStyles

					if hgs, ok := optComp.(HasGlobalStyle); ok {
						if _, exists := ctx.CollectedGlobalStyles[name]; !exists {
							if gs := hgs.GlobalStyle(); gs != "" {
								ctx.CollectedGlobalStyles[name] = gs
							}
						}
					}

					if hs, ok := optComp.(HasStyle); ok {
						scopeAttr := GetOrCreateScope(name)
						branchCtx.ScopeAttr = scopeAttr
						if _, exists := ctx.CollectedStyles[name]; !exists {
							ctx.CollectedStyles[name] = scopeCSS(hs.Style(), scopeAttr)
						}
					}

					// Call OnMount only on the active component
					if optComp == comp {
						if om, ok := optComp.(HasOnMount); ok {
							om.OnMount()
						}
					}

					branchHTML := nodeToHTML(optComp.Render(), branchCtx)

					if optComp == comp {
						activeHTML = branchHTML
					}
				}

				sb.WriteString(fmt.Sprintf("<!--%ss-->%s<!--%s-->", markerID, activeHTML, markerID))
			} else if comp != nil {
				name := componentName(comp)
				childCtx := ctx.Child(name)
				html := nodeToHTML(comp.Render(), childCtx)
				sb.WriteString(html)
			}
		default:
			sb.WriteString(escapeHTML(fmt.Sprintf("%v", v)))
		}
	}
	return sb.String()
}

// injectChainedAttrs injects AttrConds and Events into the first HTML tag.
func (h *HtmlNode) injectChainedAttrs(html string, ctx *BuildContext) string {
	var elementID string
	if len(h.Events) > 0 {
		elementID = h.Events[0].ID
	} else {
		localID := ctx.NextClassID()
		elementID = ctx.FullID(localID)
	}

	// Collect active values for each attribute (for SSR rendering)
	attrValues := make(map[string][]string)

	for _, ac := range h.AttrConds {
		trueVal := evalAttrValue(ac.TrueValue)
		falseVal := evalAttrValue(ac.FalseValue)

		if ac.Cond.Eval() {
			if trueVal != "" {
				attrValues[ac.Name] = append(attrValues[ac.Name], trueVal)
			}
		} else if falseVal != "" {
			attrValues[ac.Name] = append(attrValues[ac.Name], falseVal)
		}
	}

	var extraAttrs string
	if len(h.Events) > 0 {
		var eventNames []string
		for _, ev := range h.Events {
			eventNames = append(eventNames, ev.Event)
		}
		extraAttrs = fmt.Sprintf(` data-on="%s"`, strings.Join(eventNames, ","))
	}

	return injectIDAndMergeAttrs(html, elementID, attrValues, extraAttrs)
}

// attrToHTMLString renders a NodeAttr as an HTML attribute string.
func attrToHTMLString(attr NodeAttr, ctx *BuildContext) string {
	switch a := attr.(type) {
	case *StaticAttr:
		return fmt.Sprintf(`%s="%s"`, a.Name, escapeAttr(a.Value))
	case *DynAttrAttr:
		localID := ctx.NextAttrID()
		fullID := ctx.FullID(localID)
		var attrValue string
		for _, part := range a.Parts {
			switch v := part.(type) {
			case string:
				attrValue += v
			case *Store[string]:
				attrValue += v.Get()
			case *Store[int]:
				attrValue += fmt.Sprintf("%d", v.Get())
			}
		}
		return fmt.Sprintf(`data-attrbind="%s" %s="%s"`, fullID, a.Name, escapeAttr(attrValue))
	default:
		return ""
	}
}

// ToHTML generates HTML for a bind node (text interpolation).
func (b *BindNode) ToHTML(ctx *BuildContext) string {
	var value string
	switch s := b.StoreRef.(type) {
	case *Store[string]:
		value = s.Get()
	case *Store[int]:
		value = fmt.Sprintf("%d", s.Get())
	case *Store[bool]:
		value = fmt.Sprintf("%t", s.Get())
	case *Store[float64]:
		value = fmt.Sprintf("%g", s.Get())
	default:
		value = ""
	}

	localMarker := ctx.NextTextMarker()
	markerID := ctx.FullID(localMarker)

	if b.IsHTML {
		return fmt.Sprintf("<!--%ss-->%s<!--%s-->", markerID, value, markerID)
	}
	return fmt.Sprintf("<!--%ss-->%s<!--%s-->", markerID, escapeHTML(value), markerID)
}

// =============================================================================
// HTML Attribute Injection
// =============================================================================

// injectTextareaContent injects id attribute and replaces textarea content.
func injectTextareaContent(html, id, value string) string {
	tagEnd := findTagEnd(html)
	if tagEnd == -1 {
		return html
	}

	openTag := html[:tagEnd]
	rest := html[tagEnd+1:]

	closeTagIdx := strings.Index(strings.ToLower(rest), "</textarea>")
	if closeTagIdx == -1 {
		return openTag + fmt.Sprintf(` id="%s"`, id) + ">" + rest
	}

	return openTag + fmt.Sprintf(` id="%s"`, id) + ">" + escapeHTML(value) + rest[closeTagIdx:]
}

// ToHTML generates HTML for an if node (conditional rendering).
func (i *IfNode) ToHTML(ctx *BuildContext) string {
	localMarker := ctx.NextIfMarker()
	markerID := ctx.FullID(localMarker)

	// Render all branches to advance counters in sync with WASM.
	var activeHTML string
	activeFound := false
	for _, branch := range i.Branches {
		branchCtx := &BuildContext{
			IDCounter:             ctx.IDCounter,
			CollectedStyles:       ctx.CollectedStyles,
			CollectedGlobalStyles: ctx.CollectedGlobalStyles,
			ScopeAttr:             ctx.ScopeAttr,
		}
		branchHTML := childrenToHTML(branch.Children, branchCtx)
		ctx.IDCounter = branchCtx.IDCounter

		if !activeFound && branch.Cond.Eval() {
			activeHTML = branchHTML
			activeFound = true
		}
	}

	if len(i.ElseNode) > 0 {
		elseCtx := &BuildContext{
			IDCounter:             ctx.IDCounter,
			CollectedStyles:       ctx.CollectedStyles,
			CollectedGlobalStyles: ctx.CollectedGlobalStyles,
			ScopeAttr:             ctx.ScopeAttr,
		}
		elseHTML := childrenToHTML(i.ElseNode, elseCtx)
		ctx.IDCounter = elseCtx.IDCounter

		if !activeFound {
			activeHTML = elseHTML
		}
	}

	return fmt.Sprintf("<!--%ss-->%s<!--%s-->", markerID, activeHTML, markerID)
}

// ToHTML generates HTML for an each node (list iteration).
func (e *EachNode) ToHTML(ctx *BuildContext) string {
	localMarker := ctx.NextEachMarker()
	markerID := ctx.FullID(localMarker)

	var itemsHTML strings.Builder

	switch list := e.ListRef.(type) {
	case *List[string]:
		items := list.Get()
		if len(items) == 0 && len(e.ElseNode) > 0 {
			itemsHTML.WriteString(childrenToHTML(e.ElseNode, ctx))
		} else {
			for i, item := range items {
				itemsHTML.WriteString(nodeToHTML(e.Body(item, i), ctx))
			}
		}
	case *List[int]:
		items := list.Get()
		if len(items) == 0 && len(e.ElseNode) > 0 {
			itemsHTML.WriteString(childrenToHTML(e.ElseNode, ctx))
		} else {
			for i, item := range items {
				itemsHTML.WriteString(nodeToHTML(e.Body(item, i), ctx))
			}
		}
	}

	return fmt.Sprintf("<!--%ss-->%s<!--%s-->", markerID, itemsHTML.String(), markerID)
}

// ToHTML generates HTML for a component node (nested component).
func (c *ComponentNode) ToHTML(ctx *BuildContext) string {
	compMarker := ctx.NextCompMarker()
	fullCompPrefix := ctx.FullID(compMarker)

	comp, ok := c.Instance.(Component)
	if !ok {
		return fmt.Sprintf("<!-- component %s: invalid instance -->", c.Name)
	}

	// Collect global style (unscoped) from nested component
	if hgs, ok := c.Instance.(HasGlobalStyle); ok {
		if ctx.CollectedGlobalStyles != nil {
			if _, exists := ctx.CollectedGlobalStyles[c.Name]; !exists {
				if gs := hgs.GlobalStyle(); gs != "" {
					ctx.CollectedGlobalStyles[c.Name] = gs
				}
			}
		}
	}

	// Collect scoped style from nested component
	var scopeAttr string
	if hs, ok := c.Instance.(HasStyle); ok {
		if ctx.CollectedStyles != nil {
			if _, exists := ctx.CollectedStyles[c.Name]; !exists {
				scopeAttr = GetOrCreateScope(c.Name)
				ctx.CollectedStyles[c.Name] = scopeCSS(hs.Style(), scopeAttr)
			} else {
				scopeAttr = GetOrCreateScope(c.Name)
			}
		}
	}

	// Call OnMount when the component is rendered
	if om, ok := comp.(HasOnMount); ok {
		om.OnMount()
	}

	// Render slot content with current context
	slotHTML := childrenToHTML(c.Children, ctx)

	// Create child context for the component
	childCtx := &BuildContext{
		IDCounter:             IDCounter{Prefix: fullCompPrefix},
		SlotContent:           slotHTML,
		CollectedStyles:       ctx.CollectedStyles,
		CollectedGlobalStyles: ctx.CollectedGlobalStyles,
		ScopeAttr:             scopeAttr,
	}

	return nodeToHTML(comp.Render(), childCtx)
}

// ToHTML generates HTML for a slot node.
func (s *SlotNode) ToHTML(ctx *BuildContext) string {
	if ctx.SlotContent != "" {
		return ctx.SlotContent
	}
	return ""
}

// nodeToHTML dispatches to the appropriate ToHTML method.
func nodeToHTML(n Node, ctx *BuildContext) string {
	switch node := n.(type) {
	case *HtmlNode:
		return node.ToHTML(ctx)
	case *BindNode:
		return node.ToHTML(ctx)
	case *IfNode:
		return node.ToHTML(ctx)
	case *EachNode:
		return node.ToHTML(ctx)
	case *ComponentNode:
		return node.ToHTML(ctx)
	case *SlotNode:
		return node.ToHTML(ctx)
	default:
		return ""
	}
}

// childrenToHTML generates HTML for a slice of nodes.
func childrenToHTML(nodes []Node, ctx *BuildContext) string {
	var sb strings.Builder
	for _, n := range nodes {
		sb.WriteString(nodeToHTML(n, ctx))
	}
	return sb.String()
}

// minifyHTML collapses whitespace between tags.
func minifyHTML(s string) string {
	// Collapse whitespace between tags
	var result strings.Builder
	i := 0
	for i < len(s) {
		if s[i] == '>' {
			result.WriteByte('>')
			i++
			// Skip whitespace until next <
			start := i
			for i < len(s) && (s[i] == ' ' || s[i] == '\t' || s[i] == '\n' || s[i] == '\r') {
				i++
			}
			if i < len(s) && s[i] == '<' {
				// Whitespace between tags — skip it
			} else {
				// Whitespace before non-tag content — keep it
				result.WriteString(s[start:i])
			}
		} else {
			result.WriteByte(s[i])
			i++
		}
	}
	return strings.TrimSpace(result.String())
}

// minifyCSS removes comments, collapses whitespace, and trims unnecessary characters.
func minifyCSS(s string) string {
	// Remove comments
	for {
		start := strings.Index(s, "/*")
		if start < 0 {
			break
		}
		end := strings.Index(s[start+2:], "*/")
		if end < 0 {
			break
		}
		s = s[:start] + s[start+2+end+2:]
	}
	// Collapse whitespace
	var b strings.Builder
	inSpace := false
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c == ' ' || c == '\t' || c == '\n' || c == '\r' {
			inSpace = true
			continue
		}
		if inSpace {
			if c != '{' && c != '}' && c != ':' && c != ';' && c != ',' && c != '>' && c != '+' && c != '~' {
				if b.Len() > 0 {
					prev := b.String()[b.Len()-1]
					if prev != '{' && prev != '}' && prev != ':' && prev != ';' && prev != ',' && prev != '>' && prev != '+' && prev != '~' {
						b.WriteByte(' ')
					}
				}
			}
			inSpace = false
		}
		b.WriteByte(c)
	}
	return strings.TrimSpace(b.String())
}
